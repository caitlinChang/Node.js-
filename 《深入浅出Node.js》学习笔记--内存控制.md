[TOC]

### 内存控制
> 前言：在海量请求和长时间运行的前提下，讨论Node如何高效使用内存。


#### V8的内存限制

**为什么JavaScript为存在内存限制**

一般的后端开发语言在基本的内存使用上几乎没什么限制，然而在Node中，通过JavaScript使用内存时就会发现只能使用部分内存，在这样的限制下，导致JavaScript无法操作大内存对象。造成这种现象的原因就是JavaScript执行引擎V8存在内存限制。

##### V8的对象分配

在V8中，所有的JavaScript对象都是通过`堆`来进行分配的。当声明对象且赋值时，该对象的内存就分配在堆中。如果已申请的堆空闲内存不够分配新的对象，将继续申请内存，知道堆的大小超过V8的限制。

**为什么V8要限制堆的大小**

V8的垃圾回收机制使得V8做一次垃圾回收耗费时间过长，引起JavaScript线程暂停执行的时间花销大，因为在当时的考虑下就直接限制内存了。

##### V8的垃圾回收机制--**分代式垃圾回收机制**

`V8堆的整体大小 = 新生代内存空间 + 老生代内存空间`
- 新生代内存 <u>*存放生命周期短的对象*</u>
  `scavenge算法`，将内存一分为二，分为Form和To两块内存空间。在进行垃圾回收的时候，对Form空间进行扫描，将存活对象移动至To空间并释放非存活对象，完成复制后将两个空间角色对换。这是一种典型的以空间换时间的算法。当一个对象经过多次复制之后依然存活，就会被转移到老生代内存空间中，老生代内存中存放的是生命周期较长的对象。
  对象晋升条件：1. 经历过scavenge回收；2. To空间内存比超过限制（25%）*这是由于垃圾回收过后To空间会转变为新的Form空间，而Form空间是接收新的对象分配的空间，如果占比过大会影响后续内存分配*
- 老生代内存 <u>*存放生命周期长的对象*</u>
  `Mark-Sweep`和`Mark-Compact`，Mark-Sweep算法在进行垃圾回收时会对活对象进行标记，然后清除没有标记的对象，但是这种算法会造成内存不连续的情况出现，后续会影响大内存对象分配。Mark-Compact算法则会对清除失活对象后的内存空间进行整理。
- 增量标记(Incremental Marking)
  为了避免JavaScript应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的三种算法都需要将应用逻辑暂停下来[全停顿]，但是这样做尤其针对V8的老生代来讲耗时非常可怕。因此V8改进为将原本一口气完成的动作改为拆分成许多小步，每做完一小步就继续执行应用程序，即`增量标记`。

> **可以看出，想要高性能的执行效率，就必须注意让垃圾回收尽量少的进行。**

* * *

#### 高效使用内存

##### 变量的主动释放

1. 如果变量是全局变量，由于全局作用域需要直到进程退出才能释放，此时将导致引用的对象常驻内存，如果需要释放常驻内存的对象，可以通过`delete`操作来删除引用关系。或者将变量重新赋值，让旧的对象脱离引用关系，在接下来老生代内存清除和整理的过程中，会被回收释放。
2. 在非全局作用域中，如果想主动释放变量，也可以采用`delete`和重新赋值的方式。虽然两种方式具有同样的效果，但是V8中通过`delete`删除对象有可能干扰V8的优化，所以通过赋值方式解除引用更好。
3. 局部作用域的变量会随着局部作用域的销毁而销毁（Function）。在作用域失效后，局部变量失效，其引用的对象会在下次垃圾回收时被释放。
4. **闭包**中引用的上级变量不会在执行过后就被释放，除非不再引用该闭包，才会逐步释放。

> 在正常的JavaScript中，无法立即回收的内存有闭包和全局变量这两种情况，由于V8内存限制，要小心此类变量无限增加，导致老生代中对象增多。

* * *

#### 内存指标

##### 查看内存使用情况

1. `process.memoryUsage`可以查看内存使用情况
2. os模块中`totalmem()` 和 `freemem()` 分别返回操作系统中的总内存和闲置内存。
##### 堆外内存

Node的内存主要包括V8自行分配的部分和Node自行分配的部分(`堆外内存`)。受V8垃圾回收限制的主要是V8的堆内存;例如Buffer对象不经过V8的内存分配机制，没有堆内存的大小限制。

* * *

#### 内存泄漏

> 内存泄漏的本质，就是本该回收的对象因为各种意外没有被回收，变成了常驻在老生代中的对象。

一般情况下，造成内存泄漏的原因有如下几个：
- **缓存**
  1. 直接将内存作为缓存
 如果需要直接将内存作为缓存使用，则需要完善的过期策略以便及时释放内存。另外，进程之间无法共享内存，如果在进程内使用缓存，这些缓存不可避免地有重复，对物理内存的使用是一种浪费。
  2. 模块机制
  为了加速模块的引入，所有模块都会通过编译执行，然后被缓存起来。由于通过exports      导出的函数，可以访问文件模块中的私有变量，这样每个文件模块在编译执行后的作用域因        为模块缓存的原因，不会被释放。
  3. Node中使用大量缓存最好是采用外部缓存软件，既可以减少常驻内存的对象数量，也可以使得  进程之间共享缓存。
- **队列消费不及时**
  用数据库记录日志的情况，会形成数据库写入操作的堆积，JavaScript中相关的作用域也不会被释放，就会出现内存泄漏。
- **作用域未释放**
  闭包
    

* * *


#### 内存泄漏排查

##### `node-heapdump`

需要一份内存泄漏代码，引入`node-heapdump`,抓拍一份堆内存快照，内存快照被保存为`json`文件，可通过`Chrome`的开发者工具打开查看，打开文件可查看堆内存中详细信息，
通过在开发者工具的面板中查看内存分布，可以找到泄漏的数据，再根据这些信息找到造成泄漏的代码。

##### `node-memwatc`

在进程中使用`node-memwatch`之后，每次进行全堆垃圾回收时，就会统计内存信息，从这些统计的内存信息中可以看到垃圾回收的情况。如果经过连续5次垃圾回收后，内存仍然没有被释放，这意味着有内存泄漏的产生，`node-memwatch`会触发一个`leak`事件，显示5次垃圾回收的过程中内存增长了多少。
我们仍然需要从`leak`信息中找到泄漏的数据，再根据这些数据找到造成泄漏的代码。
`node-memewatch`提供抓取快照和比较快照的功能，通过比较堆上对象的名称和数量，找出导致内存泄漏的元凶。

#### 大内存应用
**操作大文件场景：**
`Node`提供了原生`stream`模块处理大文件。由于V8的内存限制，无法通过`fs.readFile()`和`fs.writeFile()`直接进行大文件操作，可以使用`fs.createReadStream()`和`fs.createWriteStream()`方法通过流的方式实现对大文件的操作，不受V8内存限制的影响。