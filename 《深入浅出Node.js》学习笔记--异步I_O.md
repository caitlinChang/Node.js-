[TOC]
### 为什么要使用异步I/O
**用户体验**

后端资源的反应速度会影响前端页面的展示，如果一个资源由多个不同的位置返回，异步获取资源的事件会大大小于同步获取资源的时间。

**资源分配**

Node利用单线程，避免多线程会出现的死锁、状态同步等问题；又利用异步I/O，让单线程远离阻塞，更好的利用CPU。

### 异步I/O与非阻塞I/O
> 就计算机内核I/O来说，异步/同步和阻塞/非阻塞是不同的。
> 操作系统内核对于I/O只有两种方式：阻塞与非阻塞。

**阻塞与非阻塞的区别**
1. 阻塞I/O就是调用过后一定要等到系统内核层面完成所有操作后，调用结束，才会返回调用结果。
2. 非阻塞I/O就是调用之后会立即返回调用结果，返回的是当前调用的状态。

**轮询**

在调用非阻塞I/O时，应用层为了获取到完整的数组，需要重复调用I/O操作来确认是否完成，这种重复判断操作是否完成的技术叫做轮询。

### Node的异步I/O

##### 事件循环

> Node自身的执行模型--**事件循环**。

在一个进程启动之时，Node便会创建一个类似于`while(true)`的循环，每次执行循环的过程称之为`Tick`,每次`Tick`的过程即是查看是否有事件待处理，如果有就取出事件及回调函数，执行它们，进入下一个循环，如果没有就退出循环。

> 事件循环是一个典型的**生产者/消费者模型**。

##### 观察者

每个事件循环中有一个或者多个**观察者**,判断是否有事件要处理就是询问这些**观察者**。一个观察者里可能会有多个事件。

##### 请求对象

> 对于Node中的异步I/O而言，回调函数不由开发者来调用。

一个异步调用的开始，首先由JavaScript层发起异步调用，然后Node核心模块会封装一个**请求对象**，从JavaScript层传入的参数和回调函数都被封装在这个请求对象里，其中回调函数被设置在这个对象的`oncomplete_sym`属性上；
对象包装完毕后，将这个对象放入线程池中等待执行。

##### 线程池

当线程池中有可用线程时，就会根据传入的参数调用相应的底层函数。这时，JavaScript调用立即返回，由JavaScript层面发起的异步调用的第一阶段至此结束。
当线程池中的I/O操作调用完毕之后，会将获取的结果储存在`req->resul`t属性上，然后通知IOCP，告知当前调用完成。

##### 执行回调

其实，在每次`Tick`的过程中，它会调用IOCP相关的方法检查线程池中是否有执行完的请求，如果存在，会将**请求对象**加入到I/O观察者的队列中，然后将其当作事件处理。

I/O观察者调用回调函数的行为就是取出请求对象的`result`属性作为参数，取出`oncomplete_sym`属性作为方法，然后调用执行，以此达到调用JavaScirpt传入的回调函数的目的。

至此，整个异步I/O的流程完全结束。
![09db2e625af646948eebfac70036d220](《深入浅出Node.js》学习笔记--异步I_O.resources/7DF9616C-33C7-4545-B45A-C9A4570A60D6.png)

### 非I/O的异步API

Node中还存在一些与I/O无关的异步API，如`setTimeout()`,`setInterval()`,`setImmediate()`,`process.nextTick()`。

##### setTimeout() & setInterval()

它们的实现原理与I/O类似，只是不需要I/O线程池参与。
调用`setTimeout()`和`setInterval()`创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次`Tick`执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的回调函数将立即执行。

> 定时器的问题在于，它并非精确的定时，定时的时间会有一定的延迟,这是由于事件循环自身的特点造成的。

##### process.nextTick()

> 如果立即执行一个异步任务？

采用`setTimeout(fn, 0)`的方式倒是可以立即执行一个异步任务，但是定时器的原理是通过红黑树创建定时器对象和迭代等，较为浪费性能。采用`process.nextTick()`的方式更为轻量。

每次调用`process.nextTick()`方法，只会将回调函数放入队列中，在下一轮Tick时取出执行。

定时器中采用红黑树的操作时间复杂度为`O(lg(n))`,nextTick()的时间复杂度为`O(1)`。

##### setImmediate()

> `setImmediate()`方法也是用于将回调函数延迟执行；但是该方法与`process.nextTick()`有细微差别；

`processTick()`中的回调函数执行的优先级要高于`setImmediate()`,`process.nextTick()`属于`idle`观察者，`setImmediate()`属于`check`观察者，在每一轮的循环检查中，`idle`观察者优先于I/O观察者，I/O观察者先于`check`观察者。


### 事件驱动与高性能服务器

> 事件驱动的实质是通过主循环加事件触发的方式来运行程序。

Node通过事件驱动的方式处理请求，不需要为每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任务时因为线程较少，上下文切换的代价很低。这使得服务器能够有条不紊的处理请求，即使在大量连接的情况下，也不受线程上下文切换开销的影响，这就是Node在处理I/O密集型场景高性能的一个原因。



